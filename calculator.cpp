#include "stdafx.h"
#include "illegalArugment.h"

//
int stringToInteger(std::string num)
{	
	auto result = 0;
	auto itor = num.crbegin();
	auto digit = 1;
	while (itor != num.rend())
	{
		if (  '0' <= *itor and *itor <= '9')
		{
			result += (*itor - '0') *digit;
			digit *= 10;
			++itor;
		}
		else throw illegalArugment("this string should only have number");
	}

	return result;
}


//
std::queue<std::string> split(const std::string &s, const std::string &seperator) {
	std::queue<std::string> result;
	typedef std::string::size_type string_size;
	string_size i = 0;

	while (i != s.size()) {
		//??????????????????????????????
		auto flag = 0;
		while (i != s.size() && flag == 0) {
			flag = 1;
			for (string_size x = 0; x < seperator.size(); ++x)
				if (s[i] == seperator[x]) {
					++i;
					flag = 0;
					break;
				}
		}

		//????????????????????????????????????????
		flag = 0;
		string_size j = i;
		while (j != s.size() && flag == 0) {
			for (string_size x = 0; x < seperator.size(); ++x)
				if (s[j] == seperator[x]) {
					flag = 1;
					break;
				}
			if (flag == 0)
				++j;
		}
		if (i != j) {
			result.push(s.substr(i, j - i));
			i = j;
		}
	}
	return result;
}


// ???????????????pair, first????????????????, second???????????????§µ??????????????????
std::pair<std::queue<char>, std::queue<int>>  expressionAnalysis(std::string &expression)
{
	std::pair<std::queue<char>, std::queue<int>> result;


	auto numstr = split(expression, "+-*/()");
	while (! numstr.empty())
	{	
		result.second.push(stringToInteger(numstr.front()));
		numstr.pop();
	}

	for(auto itor = expression.begin(); itor != expression.end(); ++itor)
	{
		switch (*itor)
		{
		case '+':
		case '-':
		case '*':
		case '/':
		case '(':
		case ')':
			result.first.push(*itor);
			break;
		default:;
		}
	}

	return result;
}


// ?????????????????????????????????????????????????????1?????????????-1????????????0
int comparePriority(char oper_a, char oper_b)
{
	switch (oper_a)
	{
	case '+':
	case '-':
		switch (oper_b)
		{
		case '+':
		case '-':
			return 0;
		case '*':
		case '/':
			return -1;
		default:;
		}
		break;
	case '*':
	case '/':
		switch (oper_b)
		{
		case '+':
		case '-':
			return 1;
		case '*':
		case '/':
			return 0;
		default:;
		}
		break;
	default:;
	}

	return 0;
}


//
int calculate(int a, char oper, int b)
{
	switch (oper)
	{
	case '+':
		return a + b;
	case '-':
		return a - b;
	case '*':
		return a * b;
	case '/':
		return a / b;
	default:
		return 0;
	}
}


// ?
int calculator(std::string expression)
{
	std::stack<char> operatorStack;
	std::stack<int> numberStack;
	
	auto ananysisOfExpression = expressionAnalysis(expression);
	
	operatorStack.push(ananysisOfExpression.first.front());
	ananysisOfExpression.first.pop();
	
	numberStack.push(ananysisOfExpression.second.front());
	ananysisOfExpression.second.pop();
	numberStack.push(ananysisOfExpression.second.front());
	ananysisOfExpression.second.pop();
	while (not ananysisOfExpression.first.empty() && not ananysisOfExpression.second.empty())
	{
		switch (comparePriority(operatorStack.top(), ananysisOfExpression.first.front()))
		
		{
		case -1:
			break;
		case 0:
		case 1:

			//??????????????????????????????????????
			//???????????§Ø?????????????????????????????????????????????????????????????????????????????
			while (numberStack.size() != 0 && operatorStack.size() != 0 && 
				(comparePriority(operatorStack.top(), ananysisOfExpression.first.front()) == 0 ||
					comparePriority(operatorStack.top(), ananysisOfExpression.first.front()) == 1))
			{	
				auto temp = 0;
				auto num_b = numberStack.top();
				numberStack.pop();
				auto num_a = numberStack.top();
				numberStack.pop();
				auto oper = operatorStack.top();
				operatorStack.pop();
				temp = calculate(num_a, oper, num_b);
				numberStack.push(temp);
			}
			break;

		}
		operatorStack.push(ananysisOfExpression.first.front());
		ananysisOfExpression.first.pop();
		//????????????????????????????
		//???????????????????????????????????????????????????????????????????????????
		numberStack.push(ananysisOfExpression.second.front());
		ananysisOfExpression.second.pop();
	}
	
	//????????????????????§Ø??????????§Ø????????????????????????????????§Ø?
	//????????????§Ø????????????????????????????????
	if (operatorStack.size() )
	{
		while (operatorStack.size() && numberStack.size())
		{
			auto num_b = numberStack.top();
			numberStack.pop();
			auto num_a = numberStack.top();
			numberStack.pop();
			auto oper = operatorStack.top();
			operatorStack.pop();

			auto result = calculate(num_a, oper, num_b);
			numberStack.push(result);
		}
	}
	
	return numberStack.top();
}